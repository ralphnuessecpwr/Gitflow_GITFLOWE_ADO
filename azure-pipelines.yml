name: $(Build.DefinitionName)_Branch_$(SourceBranchName)_Build.$(Rev:r)

pr: none

trigger:
- feature/*

pool:
  name: 'Default'

variables:
- group: 'gitflow_GITFLOWE'
- name: upperBranchName
  value: $[upper(variables['Build.SourceBranchName'])]
- name: branchMapping
  ${{ if contains(variables['Build.SourceBranch'], 'feature')}}:
    value: 'feature/** => UNIT,custom,PUSH TO FEATURE/$(upperBranchName)'
  ${{ elseif contains(variables['Build.SourceBranch'], 'release')}}:
    value: 'release/** => RLSE,per-branch'
- name: branchCreationRule
  ${{ if contains(variables['Build.SourceBranch'], 'feature')}}:
    value: 'custom'
  ${{ elseif contains(variables['Build.SourceBranch'], 'release')}}:
    value: 'per-branch'
- name: containerDescription
  ${{ if contains(variables['Build.SourceBranch'], 'feature')}}:
    value: 'PUSH TO FEATURE/$(upperBranchName)'
  ${{ else }}:
    value: "PUSH TO RLSE/$(upperBranchName)"
- name: codePipelineLevel
  ${{ if contains(variables['Build.SourceBranch'], 'feature')}}:
    value: 'UNIT'
  ${{ if contains(variables['Build.SourceBranch'], 'release')}}:
    value: 'RLSE'

jobs:
- job: synchMainframeCode
  condition: or(eq(variables.codePipelineLevel, 'UNIT'), eq(variables.codePipelineLevel, 'RLSE') )
  displayName: Synch Mainframe Code
  steps:
  - checkout: self
    fetchDepth: 0

# Prepare Parameters for Synchronization, depending on branch
  - task: PowerShell@2
    name: prepareSynch
    displayName: Prepare Synchronization
    env:
      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
    inputs:
      targetType: 'inline'
      script: |
        $buildNumber = $Env:BUILD_BUILDNUMBER
        $revision= $buildNumber.Substring($buildNumber.LastIndexOf('.') + 1)

        write-host "Revision Number "$revision

        $gitLocalPath               = '.\'
        $targetPath                 = '.\'
        $gitFullBranch              = "$(Build.SourceBranch)"
        $gitBranch                  = $gitFullBranch.substring($gitFullBranch.lastindexof('heads/') + 6)
        $restUri                    = "https://dev.azure.com/$(organization)/$(System.TeamProjectId)/_apis/build/builds/?definitions=$(System.DefinitionId)&branchName=$(Build.SourceBranch)&`$top=5&queryOrder=queueTimeDescending&api-version=5.1"
        
        $previousCommit             = ''

        if ($gitBranch.ToLower().Contains("feature") -and $revision -ne "1") {

          $response = Invoke-WebRequest -Uri $restUri -Headers @{"Authorization" = "Bearer $env:SYSTEM_ACCESSTOKEN"}

          if($response.StatusCode -eq 200) {

              $content        = ConvertFrom-Json $response.Content
              
          }
          else {
              
              Write-Host
              Write-Host "Query failed. Response"
              Write-Host $response

              Exit 1

          }
          
          $previousCommit   = $content.value[1].sourceVersion

        }
        else {

          $previousCommit = (git merge-base origin/development origin/$gitBranch)

        }

        Write-Host "##vso[task.setvariable variable=revision;isoutput=true]$revision"
        Write-Host "##vso[task.setvariable variable=targetPath;isoutput=true]$targetPath"
        Write-Host "##vso[task.setvariable variable=gitBranch;isoutput=true]$gitBranch"
        Write-Host "##vso[task.setvariable variable=previousCommit;isoutput=true]$previousCommit"
        Write-Host "##vso[task.setvariable variable=gitLocalPath;isoutput=true]$gitLocalPath"

  # Synchronize code for 
  # Feature Branch, if it's not the first build
  # Release Branch
  - task: PowerShell@2
    name: synchMainframeCode2Branch
    condition: or(eq(variables.codePipelineLevel, 'UNIT'), eq(variables.codePipelineLevel, 'RLSE') )
    displayName: Synchronize branch to Mainframe
    inputs:
      targetType: 'inline'
      script: |
        $revision = '$(prepareSynch.revision)'

        Write-Host 'Will synchronize Commits starting from' $(prepareSynch.previousCommit) 'and ending with' $(Build.SourceVersion)
        Write-Host 'Will map Git Branch' $gitBranch 'to ISPW Level $(codePipelineLevel), using Container Creation Rule' $(branchCreationRule)
        Write-Host
        Write-Host "Parameters"
        Write-Host
        Write-Host "Target Path       : $(prepareSynch.targetPath)"
        Write-Host "Config File       : $(codePipelineConfigYml)"
        Write-Host "Stream            : $(codePipelineStream)"
        Write-Host "App               : $(codePipelineApplication)"
        Write-Host "SubApp            : $(codePipelineSubApplication)"
        Write-Host "Assignment Prefix : $(codePipelineAssignmentPrefix)"
        Write-Host "Level             : $(codePipelineLevel)"
        Write-Host "Git Repo          : $(Build.Repository.Uri).git"
        Write-Host "Git Branch        : $(prepareSynch.gitBranch)"
        Write-Host "Git From          : $(prepareSynch.previousCommit)"
        Write-Host "Git To            : $(Build.SourceVersion)"
        Write-Host
        
        cmd.exe /c $(cliPath)\IspwCLI.bat `
          -operation syncGitToIspw `
          -host $(hostName) `
          -port $(hostHciPort) `
          -id $(hostUser) `
          -pass $(hostPassword) `
          -protocol None `
          -code $(hostCodePage) `
          -timeout 0 `
          -targetFolder $(prepareSynch.targetPath) `
          -data $(cliWorkspace) `
          -ispwServerConfig $(runtimeConfig) `
          -ispwConfigPath $(codePipelineConfigYml) `
          -ispwServerStream $(codePipelineStream) `
          -ispwServerApp $(codePipelineApplication) `
          -ispwServerSubAppl $(codePipelineSubApplication) `
          -assignmentPrefix $(codePipelineAssignmentPrefix) `
          -ispwCheckoutLevel $(codePipelineLevel) `
          -ispwContainerCreation "$(branchCreationRule)" `
          -ispwContainerDescription "$(containerDescription)" `
          -gitRepoUrl $(Build.Repository.Uri).git `
          -gitBranch $(prepareSynch.gitBranch) `
          -gitFromHash $(prepareSynch.previousCommit) `
          -gitCommit $(Build.SourceVersion) `
          -gitLocalPath $(prepareSynch.gitLocalPath)

  #- task: azure-deveops-ispw-operation-task@2
  #  name: synchMainframeCode2Branch
  #  displayName: Synchronize branch to Mainframe
  #  inputs:
  #    connectionId: $(hostConnection)      
  #    operationType: 'ISPWSYNC'
  #    windowsWorkbenchCliHome: $(cliPath)
  #    runtimeConfiguration: $(runtimeConfig)
  #    authenticationTypeIspwSync: 'USER'
  #    ispwusername: $(hostUser)
  #    ispwpassword: $(hostPassword)
  #    stream: $(codePipelineStream)
  #    application: $(codePipelineApplication)
  #    subApplication: $(codePipelineSubApplication)
  #    yamlMappingFile: $(codePipelineConfigYml)
  #    encryptionProtocol: 'NONE'
  #    codePage: '1047 - Latin 1 (Open Systems)'
  #    timeout: '0'
  #    branchMapping: $(branchMapping)

- job: checkParameters
  displayName: Check for Build Parameters
  dependsOn: synchMainframeCode
  variables:
    revision: $[ dependencies.synchMainframeCode.outputs['prepareSynch.revision'] ]
  condition: or( and( eq(variables.codePipelineLevel, 'UNIT'), ne(variables['prepareSynch.revision'], '1') ), eq(variables.codePipelineLevel, 'RLSE') )
  steps:
  - checkout: none
  - task: PowerShell@2
    name: buildParameters
    displayName: Check Results
    inputs:
      targetType: 'inline'
      script: |
        if(-not (Test-Path -Path .\automaticBuildParams.txt -PathType Leaf)) {

          Write-Host "No Mainframe Build parameters were found. Likely, no MF components were modified. The build will continue and just execute a code scan."
          Write-Host "##vso[task.setvariable variable=mainframeBuild;isoutput=true]false"

        }
        else {

          Write-Host "Mainframe Build parameters were found. Will continue with full Mainframe Build process."
        
          [string]$fileContent  = ''          
          $fileContent          = Get-Content .\automaticBuildParams.txt
          $content              = ''

          foreach ($line in $fileContent) { $content = $content + "`n" + $line }
          
          $json                 = ConvertFrom-JSON $content

          $taskParm             = ""

          foreach($taskId in $json.taskIds) {
              $taskParm = $taskParm + $taskId + ","
          }

          $taskParm = $taskParm.Substring(0,$taskParm.Length - 1)

          $taskLevel    = $json.taskLevel
          $assignmentId = $json.containerId

          Write-Host "Identified" 
          Write-Host "  Tasks"
          Write-Host $taskParm
          Write-Host "  Assignment"
          Write-Host $assignmentId
          Write-Host "  Level"
          Write-Host $taskLevel

          Write-Host "##vso[task.setvariable variable=taskIds;isoutput=true]$taskParm"
          Write-Host "##vso[task.setvariable variable=taskLevel;isoutput=true]$taskLevel"
          Write-Host "##vso[task.setvariable variable=assignmentId;isoutput=true]$assignmentId"
          Write-Host "##vso[task.setvariable variable=mainframeBuild;isoutput=true]true"
        }

- job: buildMainframeCode
  displayName: Build and Deploy Mainframe Code
  dependsOn: checkParameters
  condition: eq(variables.mainframeBuild, 'true')
  variables:
    taskIds: $[ dependencies.checkParameters.outputs['buildParameters.taskIds'] ]
    taskLevel: $[ dependencies.checkParameters.outputs['buildParameters.taskLevel'] ]
    assignmentId: $[ dependencies.checkParameters.outputs['buildParameters.assignmentId'] ]
    mainframeBuild: $[ dependencies.checkParameters.outputs['buildParameters.mainframeBuild'] ]
  steps: 
  - checkout: none
  - task: azure-deveops-ispw-operation-task@2
    displayName: Build Code
    inputs:
      connectionId: $(hostConnection)
      operationType: 'CES'
      cesUrl: $(cesUrl)
      cesSecretToken: '$(cesToken)'
      action: 'BuildAssignment'
      request: |
        runtimeConfiguration=$(runtimeConfig)
        taskIds=$(taskIds)
        assignmentId=$(assignmentId)
        application=$(codePipelineApplication)
        level=$(taskLevel)
      skipWaitingForSetCompletion: false
      showResponseBodyInConsole: true  
  - task: azure-deveops-ispw-operation-task@2
    inputs:
      connectionId: $(hostConnection)
      operationType: 'CES'
      cesUrl: $(cesUrl)
      cesSecretToken: '$(cesToken)'
      action: 'PromoteAssignment'
      request: |
        runtimeConfiguration=$(runtimeConfig)
        assignmentId=$(assignmentId)
        level=$(taskLevel)
      buildAutomatically: false
      skipWaitingForSetCompletion: false
      showResponseBodyInConsole: true